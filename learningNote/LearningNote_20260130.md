# LearningNote 2026-01-30

## 表11-1「implements と extends の使い分け」— なぜこうなるのか

### 前提：2つのキーワードの「意味」

- **extends** … 「延ばす・広げる」。**既にあるものを土台にして、その上に乗せる**イメージ。
- **implements** … 「実装する」。**契約（やるべきことの一覧）に従って、中身を書く**イメージ。

「何を引き継ぐか」が違うので、キーワードと「親の数」のルールが決まります。

---

### 1. クラス → クラス：`extends`、親は**1つだけ**

#### 何が起きているか

- 子クラスは、親クラスの**フィールド・メソッド（実装付き）をそのまま受け継ぎ**、さらに自分用のものを足したり上書きしたりする。
- つまり「**実装（コード）を継承している**」。

#### なぜ `extends` か

- 親クラスには**すでに動くコード**がある。
- 子は「そのクラスを**土台として延ばしている**」ので、**extends（延ばす）**がぴったり。
- 「実装を継承する」関係には `implements` は使いません。`implements` は「契約を満たすために中身を書く」側で使うため。

#### なぜ親は1つだけか（単一継承）

- もし「クラス A と クラス B を両方 extends」できたとする。
- A にも B にも同じ名前のメソッド `void run()` があり、**中身が違う**とする。
- 子クラスで `run()` を呼んだとき、**A の run と B の run のどちらを実行するか**が決められない（**ダイヤモンド問題**）。
- そこで Java は「**クラスからクラスへの継承は1本だけ**」にすることで、どれを引き継いだか常に明確にしている。

**まとめ**  
クラス→クラスは「実装付きの土台を1つだけ延ばす」ので `extends`、親は1つ。

---

### 2. インターフェース → クラス：`implements`、親は**1つ以上**

#### 何が起きているか

- インターフェースには**メソッドの宣言（シグネチャ）だけ**があり、**中身（実装）はない**。
- クラスは「そのインターフェースが求めるメソッドを、**全部自分で実装する**」義務を負う。

#### なぜ `implements` か

- クラスがやっているのは「**契約（インターフェース）に書いてあるメソッドを、実装する**」こと。
- 継承（既存のコードを引き継ぐ）ではなく「**契約を実装する**」ので、**implements（実装する）**が正しい。
- 逆に、ここで `extends` を使わない理由は、親側に「延ばすべき実装」が存在しないから。

#### なぜ親（インターフェース）は複数でよいか

- インターフェースには**実装がない**ので、A と B の両方を実装しても「どちらの run を実行するか」のような衝突が起きない。
- クラスは「A のメソッドも B のメソッドも、全部自分で1つずつ実装する」だけ。
- だから「**複数のインターフェースを実装してよい**」というルールになっている。

**まとめ**  
インターフェース→クラスは「契約に従って中身を書く」ので `implements`、インターフェースは複数可。

---

### 3. インターフェース → インターフェース：`extends`、親は**1つ以上**

#### 何が起きているか

- 子インターフェースは、親インターフェースが要求している**メソッドの宣言を、そのまま「要求の一覧」として受け継ぐ**。
- どちらにも**実装はない**。あくまで「こういうメソッドを持て」という**契約の範囲が広がる**だけ。

#### なぜ `extends` か（「実装がないのに extends」の理由）

- ここでの「延ばす」は**「実装を延ばす」ではなく「契約（要求の一覧）を延ばす」**という意味。
- 子インターフェースは「親の契約を土台に、さらにメソッドを足した、より大きな契約」になっている → **契約を extend している**ので `extends`。
- `implements` は「**クラスが**インターフェースの契約を**実装する**」ときに使う言葉。インターフェース同士では「実装」はしない（宣言のマージだけ）なので、`implements` ではなく `extends` を使う。

#### なぜ親（インターフェース）は複数でよいか

- インターフェースには実装がないので、複数の親インターフェースを extend しても、**同じ名前のメソッドが複数出てきても「シグネチャが同じなら1つにまとまる」**だけ。
- 実装の衝突がないため、**複数のインターフェースを extends してよい**。

**まとめ**  
インターフェース→インターフェースは「契約の範囲を延ばす」ので `extends`、親は複数可。

---

### あなたの理解へのコメント

| あなたの理解 | 補足 |
|--------------|------|
| インターフェース→インターフェースは「なにも実装していないので extends」 | その通りです。実装がないので「契約の範囲を延ばす」という意味で `extends` を使います。 |
| インターフェース→クラスは「実装を必ず行うので implements」 | その通りです。クラスが「契約を実装する」ので `implements` です。 |
| クラス→クラスは「メソッドやフィールドを記述するから？」 | 少し違うポイントがあります。大事なのは「**親の実装（コード）をそのまま引き継いで、それを土台に延ばす**」こと。子は必ずしも全部自分で書くのではなく、**親のコードを継承したうえで**足したり上書きしたりします。その「土台を1つ延ばす」関係だから `extends` で、親は1つだけです。 |

---

### 一覧で覚えるときのポイント

| 関係 | キーワード | 親の数 | 理由の一言 |
|------|------------|--------|------------|
| クラス → クラス | extends | 1つ | 実装を1つの土台から継承するため。複数だと実装の衝突（ダイヤモンド問題）。 |
| インターフェース → クラス | implements | 複数可 | 契約に従ってクラスが実装するだけ。親に実装がないので衝突なし。 |
| インターフェース → インターフェース | extends | 複数可 | 契約の範囲を延ばすだけ。実装がないので衝突なし。 |

---

## セッションログ（ユーザー入力＋回答）

### 抽象メソッドがあるクラスが抽象クラスになる理由（→の意味）

ユーザー:
抽象メソッド (未完成部分)が 1つ でもあるクラスは、抽象クラスにしなければコンパイルが通 らないしくみの説明にはなっていないのではないでしょうか？
「詳細 未定」の抽象 メ ソッ ドがある→ その クラスは必ず抽象 ク
ラス になる
ここの→に移行する理由を説明してほしいです

アシスタント:
画像の「→」の部分、つまり**「抽象メソッドが1つでもあると、なぜそのクラスは必ず抽象クラスにしなければならないか」**を、言語仕様の理由として整理します。

#### 「→」の理由：なぜ「抽象メソッドあり ⇒ 抽象クラス」なのか

##### 1. 抽象メソッドは「実装がない」メソッド

- 抽象メソッドは**宣言（シグネチャ）だけ**で、**中身（本体）が未定義**です。
- つまり「このメソッドはあるが、何をするかはこのクラスでは決めていない」状態です。

##### 2. そのクラスを普通のクラスのままにすると何が起きるか

もし「抽象メソッドが1つでもあるクラス」を、そのまま**通常のクラスとしてインスタンス化できる**ようにしてしまうと：

- `new そのクラス()` でオブジェクトが作れる
- そのオブジェクトには、**実装のないメソッド**が含まれる
- 誰かがそのメソッドを呼んだときに**実行するコードが存在しない**  
  → 実行時エラーや未定義動作になる

つまり、「未完成なメソッドを持つオブジェクト」が世に出てしまう設計になります。

##### 3. だから「抽象クラス」にさせる

そこで言語の設計として、

- **「実装が未定のメソッドを1つでも持つクラスは、インスタンス化してはいけない」**
- そのことをコンパイラに**型として明示する**ために、「そのクラスは抽象クラスである」と宣言させる

というルールにしています。

- **抽象クラス** = 「このクラスからは直接 `new` してインスタンスを作ってはいけない」とコンパイラに伝える印
- 「抽象メソッドが1つでもある → そのクラスは必ず抽象クラス」の **→** は、  
  **「未完成なメソッドを持つクラスは、未完成なインスタンスが作られないよう、抽象クラスとして宣言し、インスタンス化を禁止する」**  
  という設計上の理由を満たすため、という説明になります。

##### 4. まとめ（「→」の意味）

| 事実 | 結果 |
|------|------|
| 抽象メソッド = 実装が未定 | そのクラスのインスタンスには「呼べないメソッド」が含まれる |
| そんなインスタンスを作れると危険 | だから「そのクラスからはインスタンスを作らせない」必要がある |
| その「作らせない」を表す型が抽象クラス | だから「抽象メソッドが1つでもあるクラスは、抽象クラスにしなければならない」 |

つまり、**「詳細未定の抽象メソッドがある → そのクラスは必ず抽象クラスになる」** の「→」は、  
「未完成な設計図から実体（インスタンス）が作られるのを、型システムで防ぐため」という理由で繋がっています。

この説明を学習ノートに追記する場合は、`LearningNote_20260130.md` の続きに上記をそのまま貼る形で使えます。必要なら、ノート用に要約版も書けます。

---

### implements と extends の使い分けと親の数（表11-1の理由）

ユーザー:
なぜこうなるのでしょうか？
こうなる理由を一つ一つ丁寧に分かりやすく詳細に教えてほしいです
私の理解は下記のとおりです
インターフェース→インターフェースは、恐らくですが、なにも実装していないのでextendsなのでしょう。
インターフェース→クラスは、実装を必ず行う必要があるので、implementsなのでしょう。
クラス→クラスが一番あいまいでよくわかっていません。実装するにしろしないにしろ必ずメソッドやフィールドを記述する必要があるからでしょうか

アシスタント:
学習ノートに、表の「なぜこうなるか」を理由付きでまとめました。要点だけここに書きます。

---

#### 1. クラス → クラス：`extends`、親は**1つだけ**

- **何をしているか**  
  親クラスの**実装（フィールド・メソッドのコード）をそのまま引き継いで、その上に足したり上書きしたりしている**。
- **なぜ `extends` か**  
  「既にある実装を**土台として延ばす**」関係なので、**extends（延ばす）**が合う。  
  実装を「継承」する側なので、`implements`（契約を実装する）ではない。
- **なぜ親は1つだけか**  
  親を2つ以上にすると、同じ名前のメソッドで**中身が違う**場合に、どれを実行するか決まらない（**ダイヤモンド問題**）。  
  だから Java は「クラスからクラスの継承は1本だけ」にしている。

クラス→クラスが「あいまい」に感じる部分は、**「実装を書く」のではなく「親の実装を引き継いだうえで、必要なら足す・上書きする」**という点です。その「1つの土台を延ばす」関係だから `extends` で、親は1つだけ、と覚えると整理しやすいです。

---

#### 2. インターフェース → クラス：`implements`、親は**複数可**

- **何をしているか**  
  インターフェースは「メソッドの宣言だけ」。クラスはその**宣言に従って中身を全部書く**（実装する）。
- **なぜ `implements` か**  
  やっていることが「**契約（インターフェース）を実装する**」なので、`implements` がそのままの意味になる。
- **なぜ複数インターフェースでよいか**  
  親側に実装がないので、「どちらの実装を使うか」の衝突が起きない。  
  「A のメソッドも B のメソッドも、このクラスが1つずつ実装する」だけなので、複数でよい。

あなたの理解「実装を必ず行うので implements」で合っています。

---

#### 3. インターフェース → インターフェース：`extends`、親は**複数可**

- **何をしているか**  
  どちらにも実装はなく、「こういうメソッドを持て」という**契約の範囲**を、子が親を土台に**広げている**だけ。
- **なぜ `extends` か**  
  ここでの「延ばす」は**実装ではなく「契約（要求の一覧）を延ばす」**という意味。  
  子インターフェース = 「親の契約 + 追加のメソッド」なので、**契約を extend している** → `extends`。  
  `implements` は「クラスが契約を実装する」ときに使うので、インターフェース同士の「宣言のマージ」には `extends` を使う。
- **なぜ複数でよいか**  
  実装がないので、複数 extend しても衝突しない（同じ名前なら「同じ契約が1つ」になるだけ）。

あなたの理解「なにも実装していないので extends」で大筋合っています。より正確には「**契約だけを延ばしているから extends**」です。

---

#### 表の「なぜこうなるか」の一言まとめ

| 関係 | キーワード | 親の数 | 理由の一言 |
|------|------------|--------|------------|
| クラス → クラス | extends | 1つ | 実装を1つの土台から継承。複数だと実装の衝突。 |
| インターフェース → クラス | implements | 複数可 | 契約をクラスが実装するだけ。親に実装なしなので衝突なし。 |
| インターフェース → インターフェース | extends | 複数可 | 契約の範囲を延ばすだけ。実装なしなので衝突なし。 |

詳しい説明と、あなたの理解へのコメントは `LearningNote_20260130.md` に書いてあるので、あとから見返して整理しやすいと思います。
